@startuml qaas


  enum ScoringCriterion {
    
  }

  enum NodeType {
    Issue
    Proposal
    Pro
    Con
    Reference
  }

  class ScoringStrategy {
    name String
    criterion ScoringCriterion
    evalMove(ConversationNode): float
    evalQuest(GamePlay, GamePlay): Badge[]
  }

  class AccountService {
    name String
    url String
  }

  enum MembershipStatus {
    request
    invitation
    confirmed
  }


  enum QuestStatus {
    draft
    registration
    ongoing
    scoring
    finished
  }

  enum Permissions {
    superadmin
    viewGuild
    viewQuest
    createQuest
    createGuild
    ' Guild permissions
    acceptGuildMembership
    revokeGuildMembership
    inviteMember
    publishGameMove
    retractGameMove
    joinQuest
    guildAdmin
    setGameFocus
    ' within term time
    ' Quest permissions
    acceptQuestMembership
    revokeQuestMembership
    rejectGameMove
    ' extraCreditForMove may have issues with favoritism
    
  }

  ' Note: attach permissions to roles

  class TurnStrategy {
    synchronous boolean
    turnLength interval
  }

  enum PubState {
    private_draft
    guild_draft
    proposed
    submitted
    visible
    obsolete
    ' visible and submitted are the same for v1
  }

  enum Metric {

  }

  enum BadgeType {

  }

  enum GameMoveType {
    add_node
    ' Eventually refactorings
  }

  class Member {
    server ExternalServer
    handle String
    name String
    email String
    password String
    permissions Permission[]
  }
  class Account {
    Member member
    service AccountService
    string id
  }
  Account --> "1" AccountService
  Member "1" --> "*" Account

  class Guild {
    server ExternalServer
    name String
    handle String
    public boolean
    open_for_applications boolean
    accept(GamePlay)
  }
  ' Guild --> "0..1" ExternalServer
  ' Quest --> "0..1" ExternalServer
  ' Member --> "0..1" ExternalServer
  class Quest {
    server ExternalServer
    name String
    description String
    handle String
    public boolean
    scoring ScoringStrategy
    turns TurnStrategy
    status QuestStatus
    scoreMove(ConversationNode): GameMoveScore[]
    register(Guild): GamePlay
  }
  Quest o--> "1" Member : > creator
  Quest o--> "*" Member : > moderators
  (Quest, Member) .. QuestMembership


  class QuestMembership {
    quest Quest
    member Member
    status MembershipStatus
    permissions Permission[]
  }
  Guild o--> "1" Member : > creator
  Guild o--> "*" Member : > members

  (Member , Guild) .. GuildMembership

  class GuildMembership { 
    guild Guild
    member Member
    status MembershipStatus
    boolean leadership
    permissions Permission[]
  }

  class ExternalServer {
    server_api URL
    name String
  }


  class ConversationNode {
    quest Quest
    creator Member
    node_type NodeType
    move_type GameMoveType
    contributors Casting[]
    title String
    description String
    state PubState
    state_history <PubState, timestamp>[]
    ' GamePhase inferred from history?
    ' allow more history than PubState?
    parent ConversationNode
    ancestry() ConversationNode[]
    ' may materialize in a ltree
  }

  class NodeReplacement {
    new_node ConversationNode
    replacing_node ConversationNode
    approved_by Casting[]
    effective timestamp
  }

  (ConversationNode, ConversationNode) .. NodeReplacement
  NodeReplacement --> "*" Casting : > approvals

  ConversationNode "*" o--> "1..*" Casting
  ' Quest o--> ScoringStrategy

  Member "1" <-- "*" ConversationNode : < creator
  ConversationNode "1" o-> "0..1" ConversationNode : > parent
  Quest "1" o--> "*" ConversationNode
  
  class GameMoveScore {
    guild Guild
    moves ConversationNode[]
    metric Metric
    value float
    strategy ScoringStrategy
    quest_signature crypto
    badge BadgeType
  }
  ConversationNode "1..*" <-- "*" GameMoveScore
  Quest *--> "*" GameMoveScore
  class ScoreAssignment {
    from_score GameMoveScore
    casting Casting
    value float
    ' Should I put all values in one assignment? Easier to check the total constraint.
    badge BadgeType
    guild_signature crypto
  }

  (Casting, GameMoveScore) .. ScoreAssignment

  Member "1" ..> "*" ScoreAssignment

  ' GameMoveScore --> "1" ScoringStrategy
  ' NOTE: GameMoveScore given by Quest, distribution of points to contributors is decided by guild
  ' TODO: Score for a set of related game moves.
  ' Q: are badges automated based on score? Possibly.
  ' Are all points given by quest? Cross-guild scoring?
  ' Maybe pre-announce number of points given by quest? Success criteria?

  ' Question: Should I allow multiple avatars in a guild, reusable between quests?
  ' Vs the Casting which is a way to play a game under a quest-specific identity...
  ' That creates the question: Do the points/badges belong to the Avatar or the Member?

  class Avatar {
    ' Note: for v1, a single avatar.
    member Member
    server Server
    badges BadgeType[]
    scores {Metric->float}
    name String
    ' defaults to member's handle
    ' (server+name unique)

    ' v2
    roles Role[]
  }

  Member "1" o--> "*" Avatar

  class Casting {
    ' note: denormalized for uniqueness constraints
    quest Quest
    member Member
    ' (quest+member unique)
    guild Guild
    ' Constrain that the member be in playing guild

    ' v1:
    roles Role[]
    permissions Permission[]

    ' v2:
    avatar Avatar
    ' Constrain avatar having same member
    ' some permissions would be inherent in avatar's roles
    alias String
    ' alias defaults to avatar handle
    ' (quest+alias unique)
  }

  class GamePlay {
    Quest quest
    Guild guild
    status MembershipStatus
    proposed timestamp
    accepted timestamp
    guild_focus ConversationNode
    scores {Metric->float}
  }

  (Guild , Quest) .. GamePlay
  (Avatar, GamePlay) .. Casting

  class GamePhase {
    quest Quest
    start timestamp
    end timestamp
    synchronous boolean
    singlePlayer Guild
  }

  Quest "1" o--> "*" GamePhase

@enduml
